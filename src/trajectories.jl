# TRAJECTORY CALCULATION #

const DEFAULT_DT = 0.001

"""
   compute_trajectory(u,v,X₀::Vector,Tmax[,Δt=0.001])

Calculate the trajectory of a tracer particle with initial location(s) `X₀`, which
can be specified as either a single vector `[x0,y0]` or a vector of vectors
for multiple tracer particles. The arguments
`u` and `v` are interpolated velocity field components, `Tmax` is the final
integration time, and `Δt` is the time step size. The output is the solution
structure for the `OrdinaryDiffEq` package (or, for multiple particles, a vector
of such solution structures).
"""
function compute_trajectory(ufield::AbstractInterpolation{T,2},
                            vfield::AbstractInterpolation{T,2},
                            X₀::Vector{S},Tmax::Real;Δt::Real=DEFAULT_DT) where {T,S<:Real}

  vfcn!(dR,R,p,t) = _vfcn_autonomous!(dR,R,p,t,ufield,vfield)

  sol = _solve_trajectory(vfcn!,X₀,Tmax,Δt)
  return sol

end

function compute_trajectory(ufield::AbstractInterpolation{T,2},vfield::AbstractInterpolation{T,2},
   pts::Vector{Vector{S}},Tmax;Δt=DEFAULT_DT) where {T,S<:Real}

  sol_array = ODESolution[]
  for X₀ in pts
    sol = compute_trajectory(ufield,vfield,X₀,Tmax,Δt=Δt)
    push!(sol_array,sol)
  end
  return sol_array

end


"""
   compute_trajectory(vel::Edges,sys,X₀::Vector/Vector{Vector},Tmax[,Δt=0.001])

Calculate the trajectory of a particle with initial location `X₀`. The argument
`vel` is edge-type grid data, `sys` is a Navier-Stokes type system, `Tmax` is the final
integration time, and `Δt` is the time step size. The output is the solution
structure for the `OrdinaryDiffEq` package.
"""
compute_trajectory(u::Edges, sys::NavierStokes, X₀::Union{Vector{S},Vector{Vector{S}}},Tmax;Δt=DEFAULT_DT) where S <: Real =
    compute_trajectory(interpolatable_field(u,sys.grid)...,X₀,Tmax;Δt=Δt)

"""
    compute_trajectory(elements,X₀::Vector,Tmax[,Δt=0.001])

Calculate the trajectory of a particle with initial location `X₀`. The
argument `elements` is a potential flow `Element` type or group of `Element` types.
`Tmax` is the final integration time, and `Δt` is the time step size. The output is the solution
structure for the `OrdinaryDiffEq` package.
"""
function compute_trajectory(elements, X₀::Vector{S}, Tmax; Δt=DEFAULT_DT) where S <: Real

  function vfcn!(dR,R,p,t)
    dR_complex = induce_velocity(R[1]+im*R[2], elements, t)
    dR[1] = real(dR_complex)
    dR[2] = imag(dR_complex)
    return dR
  end

  sol = _solve_trajectory(vfcn!,X₀,Tmax,Δt)
  return sol

end

function _solve_trajectory(vfcn!,u0,Tmax,Δt)
  Path = ODEProblem(vfcn!,u0,(0.0,Tmax))
  sol = solve(Path,Tsit5(), dt = Δt, maxiters = 1e8, adaptive = false, dense = false)
end


"""
   compute_trajectories(elements,tracer_start,Tmax[,Δt=0.001])

Calculate the trajectories of a set of tracer particles in a potential flow
generated by the elements `elements`. The tracers' initial positions are
provided as a vector of complex positions in `tracer_start`. The final time
and time step are provided as `Tmax` and `Δt`. The output is a tuple of arrays
of the x and y coordinates of the trajectories. Each column of these
arrays corresponds to a single tracer history.
"""
function compute_trajectories(elements, tracer_start::Vector{<:Number}, Tmax; Δt=DEFAULT_DT)

   tracer_x = []
   tracer_y = []
   for z0 in tracer_start
       sol = compute_trajectory(elements,[real(z0),imag(z0)],Tmax,Δt=Δt)
       xy = transpose(hcat(sol.u...))
       push!(tracer_x,xy[:,1])
       push!(tracer_y,xy[:,2])
   end
   x = hcat(tracer_x...)
   y = hcat(tracer_y...)

   return x, y

end



function _vfcn_autonomous!(dR,R,p,t,u,v)
 dR[1] = u(R[1],R[2])
 dR[2] = v(R[1],R[2])

return dR
end

"""
  field_along_trajectory(f::GridData,sys::NavierStokes,traj::ODESolution[,deriv=0])

Evaluate field `f` (given as grid data) along the trajectory specified by `traj`.
The output is the history of `f` along this trajectory. If `f` is a vector field,
then the component histories are output as a tuple. If `deriv=1`, then it
computes the time derivative of the field along the trajectory. The default
is `deriv=0` (no derivative).
"""
field_along_trajectory(d::GridData,sys,traj;deriv=0) = _field_along_trajectory(d,sys,traj,Val(deriv))

function _field_along_trajectory(v::VectorGridData,sys::NavierStokes,traj::ODESolution,::Val{0})
 vfield_x, vfield_y = interpolatable_field(v,sys.grid)

 vx_traj = eltype(v)[]
 vy_traj = eltype(v)[]
 for x in traj.u
   push!(vx_traj,vfield_x(x...))
   push!(vy_traj,vfield_y(x...))
 end

 return vx_traj, vy_traj
end


function _field_along_trajectory(s::ScalarGridData,sys::NavierStokes,traj::ODESolution,::Val{0})
 sfield = interpolatable_field(s,sys.grid)

 s_traj = eltype(sfield)[]
 for x in traj.u
   push!(s_traj,sfield(x...))
 end

 return s_traj
end

function _field_along_trajectory(v::VectorGridData,sys::NavierStokes,traj::ODESolution,::Val{1})
    utraj, vtraj = _field_along_trajectory(v,sys,traj,Val(0))
    return ddt(utraj,traj.t), ddt(vtraj,traj.t)
end

_field_along_trajectory(s::ScalarGridData,sys::NavierStokes,traj::ODESolution,::Val{1}) =
    ddt(_field_along_trajectory(s,sys,traj,Val(0)),traj.t)
